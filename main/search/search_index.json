{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#motivation","title":"Motivation","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>astrotech</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>astrotech</code> to a new version will possibly break any code that was using the old version of <code>astrotech</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>astrotech</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install astrotech\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>astrotech</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'astrotech[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install astrotech numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>astrotech</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/astrotech.git\n</code></pre> <p>It is recommended to create a Python 3.9+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate astrotech\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>astrotech</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#astrotech.utils","title":"astrotech.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#astrotech.utils.event","title":"astrotech.utils.event","text":"<p>Contain utility functions to manage events.</p>"},{"location":"refs/utils/#astrotech.utils.event.ConditionalEventHandler","title":"astrotech.utils.event.ConditionalEventHandler","text":"<p>               Bases: <code>ConditionalEventHandler</code></p> <p>Implements a variant of <code>minvent.ConditionalEventHandler</code> to not show the arguments in the to string method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; from astrotech.utils.event import ConditionalEventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n&gt;&gt;&gt; print(repr(handler))\nConditionalEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n  (condition): PeriodicCondition(freq=3, step=0)\n)\n&gt;&gt;&gt; print(str(handler))\nConditionalEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (condition): PeriodicCondition(freq=3, step=0)\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.event.EventHandler","title":"astrotech.utils.event.EventHandler","text":"<p>               Bases: <code>EventHandler</code></p> <p>Implements a variant of <code>minvent.EventHandler</code> to not show the arguments in the to string method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.event import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; print(repr(handler))\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; print(str(handler))\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.factory","title":"astrotech.utils.factory","text":"<p>Contain object factory utility functions.</p>"},{"location":"refs/utils/#astrotech.utils.factory.setup_object","title":"astrotech.utils.factory.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.factory import setup_object\n&gt;&gt;&gt; linear = setup_object(\n...     {\"_target_\": \"torch.nn.Linear\", \"in_features\": 4, \"out_features\": 6}\n... )\n&gt;&gt;&gt; linear\nLinear(in_features=4, out_features=6, bias=True)\n&gt;&gt;&gt; setup_object(linear)  # Do nothing because the module is already instantiated\nLinear(in_features=4, out_features=6, bias=True)\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.factory.str_target_object","title":"astrotech.utils.factory.str_target_object","text":"<pre><code>str_target_object(config: dict) -&gt; str\n</code></pre> <p>Get a string that indicates the target object in the config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A config using the <code>objectory</code> library. This dict is expected to have a key <code>'_target_'</code> to indicate the target object.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string with the target object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.factory import str_target_object\n&gt;&gt;&gt; str_target_object({OBJECT_TARGET: \"something.MyClass\"})\nsomething.MyClass\n&gt;&gt;&gt; str_target_object({})\nN/A\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.logging","title":"astrotech.utils.logging","text":"<p>Contain utility functions to manage loggers.</p>"},{"location":"refs/utils/#astrotech.utils.logging.disable_logging","title":"astrotech.utils.logging.disable_logging","text":"<pre><code>disable_logging(\n    level: int | str = logging.CRITICAL,\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Context manager to temporarily disable the logging.</p> <p>All logging calls of severity <code>level</code> and below will be disabled.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>The logging level.</p> <code>CRITICAL</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; from astrotech.utils.logging import disable_logging\n&gt;&gt;&gt; with disable_logging(\"INFO\"):\n...     logging.critical(\"CRITICAL\")\n...     logging.info(\"INFO\")\n...     logging.debug(\"DEBUG\")\n...\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.mapping","title":"astrotech.utils.mapping","text":"<p>Contain utility functions to manipulate mappings/dicts.</p>"},{"location":"refs/utils/#astrotech.utils.mapping.convert_to_dict_of_lists","title":"astrotech.utils.mapping.convert_to_dict_of_lists","text":"<pre><code>convert_to_dict_of_lists(\n    seq_of_mappings: Sequence[Mapping],\n) -&gt; dict[Hashable, list]\n</code></pre> <p>Convert a sequence of mappings to a dictionary of lists.</p> <p>All the dictionaries should have the same keys. The first dictionary in the sequence is used to find the keys.</p> <p>Parameters:</p> Name Type Description Default <code>seq_of_mappings</code> <code>Sequence[Mapping]</code> <p>The sequence of mappings to convert.</p> required <p>Returns:</p> Type Description <code>dict[Hashable, list]</code> <p>A dictionary of lists.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.mapping import convert_to_dict_of_lists\n&gt;&gt;&gt; convert_to_dict_of_lists(\n...     [{\"key1\": 1, \"key2\": 10}, {\"key1\": 2, \"key2\": 20}, {\"key1\": 3, \"key2\": 30}]\n... )\n{'key1': [1, 2, 3], 'key2': [10, 20, 30]}\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.mapping.convert_to_list_of_dicts","title":"astrotech.utils.mapping.convert_to_list_of_dicts","text":"<pre><code>convert_to_list_of_dicts(\n    mapping_of_seqs: Mapping[Hashable, Sequence]\n) -&gt; list[dict]\n</code></pre> <p>Convert a mapping of sequences to a list of dictionaries.</p> <p>All the sequences should have the same length.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_of_seqs</code> <code>Mapping[Hashable, Sequence]</code> <p>The mapping of sequences to convert.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A dictionary of lists.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.mapping import convert_to_list_of_dicts\n&gt;&gt;&gt; convert_to_list_of_dicts({\"key1\": [1, 2, 3], \"key2\": [10, 20, 30]})\n[{'key1': 1, 'key2': 10}, {'key1': 2, 'key2': 20}, {'key1': 3, 'key2': 30}]\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.mapping.get_first_value","title":"astrotech.utils.mapping.get_first_value","text":"<pre><code>get_first_value(data: Mapping) -&gt; Any\n</code></pre> <p>Get the first value of a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping</code> <p>The input mapping.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The first value in the mapping.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.mapping import get_first_value\n&gt;&gt;&gt; get_first_value({\"key1\": 1, \"key2\": 2})\n1\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.mapping.remove_keys_starting_with","title":"astrotech.utils.mapping.remove_keys_starting_with","text":"<pre><code>remove_keys_starting_with(\n    mapping: Mapping, prefix: str\n) -&gt; dict\n</code></pre> <p>Remove the keys that start with a given prefix.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The original mapping.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to find the keys to remove</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A new dict without the removed keys.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.mapping import remove_keys_starting_with\n&gt;&gt;&gt; remove_keys_starting_with(\n...     {\"key\": 1, \"key.abc\": 2, \"abc\": 3, \"abc.key\": 4, 1: 5, (2, 3): 6},\n...     \"key\",\n... )\n{'abc': 3, 'abc.key': 4, 1: 5, (2, 3): 6}\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.mapping.to_flat_dict","title":"astrotech.utils.mapping.to_flat_dict","text":"<pre><code>to_flat_dict(\n    data: Any,\n    prefix: str | None = None,\n    separator: str = \".\",\n    to_str: (\n        type[object] | tuple[type[object], ...] | None\n    ) = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Compute a flat representation of a nested dict with the dot format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The nested dict to flat.</p> required <code>prefix</code> <code>str | None</code> <p>The prefix to use to generate the name of the key. <code>None</code> means no prefix.</p> <code>None</code> <code>separator</code> <code>str</code> <p>The separator to concatenate keys of nested collections.</p> <code>'.'</code> <code>to_str</code> <code>type[object] | tuple[type[object], ...] | None</code> <p>The data types which will not be flattened out, instead they are converted to a string.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The flatted data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.mapping import to_flat_dict\n&gt;&gt;&gt; data = {\n...     \"str\": \"def\",\n...     \"module\": {\n...         \"component\": {\n...             \"float\": 3.5,\n...             \"int\": 2,\n...         },\n...     },\n... }\n&gt;&gt;&gt; to_flat_dict(data)\n{'str': 'def', 'module.component.float': 3.5, 'module.component.int': 2}\n&gt;&gt;&gt; # Example with lists (also works with tuple)\n&gt;&gt;&gt; data = {\n...     \"module\": [[1, 2, 3], {\"bool\": True}],\n...     \"str\": \"abc\",\n... }\n&gt;&gt;&gt; to_flat_dict(data)\n{'module.0.0': 1, 'module.0.1': 2, 'module.0.2': 3, 'module.1.bool': True, 'str': 'abc'}\n&gt;&gt;&gt; # Example with lists with to_str=(list) (also works with tuple)\n&gt;&gt;&gt; data = {\n...     \"module\": [[1, 2, 3], {\"bool\": True}],\n...     \"str\": \"abc\",\n... }\n&gt;&gt;&gt; to_flat_dict(data)\n{'module.0.0': 1, 'module.0.1': 2, 'module.0.2': 3, 'module.1.bool': True, 'str': 'abc'}\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.param","title":"astrotech.utils.param","text":"<p>Contain utility functions for <code>torch.nn.Parameter</code> objects.</p>"},{"location":"refs/utils/#astrotech.utils.param.is_parameter","title":"astrotech.utils.param.is_parameter","text":"<pre><code>is_parameter(value: Any) -&gt; bool\n</code></pre> <p>Indicate if the input value is a <code>torch.nn.Parameter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input value is a <code>torch.nn.Parameter</code>, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn import Parameter, UninitializedParameter\n&gt;&gt;&gt; from astrotech.utils.param import is_parameter\n&gt;&gt;&gt; is_parameter(Parameter(torch.ones(2, 3)))\nTrue\n&gt;&gt;&gt; is_parameter(UninitializedParameter())\nTrue\n&gt;&gt;&gt; is_parameter(torch.ones(2, 3))\nFalse\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.param.is_uninitialized_parameter","title":"astrotech.utils.param.is_uninitialized_parameter","text":"<pre><code>is_uninitialized_parameter(value: Any) -&gt; bool\n</code></pre> <p>Indicate if the input value is a <code>torch.nn.UninitializedParameter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Specifies the value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input value is a <code>torch.nn.UninitializedParameter</code>, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torch.nn import Parameter, UninitializedParameter\n&gt;&gt;&gt; from astrotech.utils.param import is_uninitialized_parameter\n&gt;&gt;&gt; is_uninitialized_parameter(UninitializedParameter())\nTrue\n&gt;&gt;&gt; is_uninitialized_parameter(Parameter(torch.ones(2, 3)))\nFalse\n&gt;&gt;&gt; is_uninitialized_parameter(torch.ones(2, 3))\nFalse\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.time","title":"astrotech.utils.time","text":"<p>Contain utility functions to measure time.</p>"},{"location":"refs/utils/#astrotech.utils.time.sync_perf_counter","title":"astrotech.utils.time.sync_perf_counter","text":"<pre><code>sync_perf_counter() -&gt; float\n</code></pre> <p>Extension of <code>time.perf_counter</code> that waits for all kernels in all streams on a CUDA device to complete.</p> <p>Returns:</p> Type Description <code>float</code> <p>Same as <code>time.perf_counter()</code>. See https://docs.python.org/3/library/time.html#time.perf_counter for more information.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.time import sync_perf_counter\n&gt;&gt;&gt; tic = sync_perf_counter()\n&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; toc = sync_perf_counter()\n&gt;&gt;&gt; toc - tic\n</code></pre>"},{"location":"refs/utils/#astrotech.utils.time.timeblock","title":"astrotech.utils.time.timeblock","text":"<pre><code>timeblock(\n    message: str = \"Total time: {time}\",\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to measure the execution time of a block of code.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message displayed when the time is logged.</p> <code>'Total time: {time}'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from astrotech.utils.time import timeblock\n&gt;&gt;&gt; with timeblock():\n...     x = [1, 2, 3]\n...\n&gt;&gt;&gt; with timeblock(\"Training: {time}\"):\n...     y = [1, 2, 3]\n...\n</code></pre>"}]}